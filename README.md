# Hoke  提供性能良好的异步的方法通知
#####要求jdk 1.7及以上版本
#####属于axe框架插件

##使用场景
* 为非常耗时的查询方法提速，当Hoke管理的方法执行几遍后，就能达到毫秒级的查询速度。
* 特别适合，比如无参数或者每次参数都一样，但是每次结果都不同的方法，而且极为耗时。

##需要知悉的点
* Hoke管理的方法，默认配置下，需要执行一次多次后，速度就会变快。
* @HokeConfig注解过的方法，可能会导致其他的切面注解失效(如)，其实这也好理解，因为当数据不再真正从方法获取的时候，就不用不到方法上的其他切面注解了。
* @HokeConfig注解的方法，传递的参数必须都重写hashCode，Hoke根据hashCode辨别参数是否一样。
* 切勿滥用Hoke，比如修改订单状态这种方法，本身就不要加hoke，况且内部还包含事务处理，除此以外，90%的查询方法基本都可加上Hoke来提速。
* 被加速后的方法，执行得到的结果与真实结果之间会稍有延迟，举例比如：订单状态在1ms前被改成已支付，如果订单状态查询方法是被Hoke管理的，那么1ms后调用此方法得到的结果或许、可能，还不是最新的数据，不过实际上这也没关系，因为现实场景下，查询本身就不是完全实时的(我们查到的数据，都可以认为是数据库中数据的一个快照而已)，所以只要注意在对数据做修改的时候不要加Hoke即可。

##有待增加
* POOL分片到磁盘，减小内存利用
* 提高内存清空效率

##正在进行
* 为Hoke增加Captain支持，支持缓存均衡分布到Captain组员机，且根据组员机数量动态调整
* 支持提空开发者自我扩展均衡分布的策略HokeCaptainStrategy
* 默认的均衡分布策略支持
 * 动态根据机器数量，将请求按照新的组内情况，分配给组员
 * 在调整分配后，提醒其余组员删除无用的内容，这可以给机器减小压力，当动态增加新组员后，老组员的资源利用率会显著下降，这是系统的横向弹性扩充的最大意义。提高系统瓶颈的同时，也能显著减小原有组员的压力。

##Get Start
* @Hoke
* @HokeConfig
 * lazyLoad
 * refreshSeconds
 * timeOut
* 配置参数
 * axe.hoke.cache_file_dir
 * axe.hoke.captain.strategy
* HokeCaptainStrategy Captain策略
* 访问 hoke/proxy 使用Axe-Captain
* 访问 监控页面 /hoke